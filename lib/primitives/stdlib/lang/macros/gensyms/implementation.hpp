// Author: Jordan Randleman -- jrandleman@scu.edu -- implementation.hpp
// => Defines helper functions for gensyms.hpp

#ifndef HEIST_SCHEME_CORE_STDLIB_GENSYMS_IMPLEMENTATION_HPP_
#define HEIST_SCHEME_CORE_STDLIB_GENSYMS_IMPLEMENTATION_HPP_

namespace heist::stdlib_gensyms {

  // Returns a freshly generated gensym symbol
  string new_hashed_gensym_arg()noexcept{
    if(G.GENSYM_HASH_IDX_1 != GLOBALS::MAX_SIZE_TYPE)
      return symconst::gensym_prefix + std::to_string(G.GENSYM_HASH_IDX_2) + 
                                 '_' + std::to_string(G.GENSYM_HASH_IDX_1++);
    return symconst::gensym_prefix + std::to_string(++G.GENSYM_HASH_IDX_2) + 
                               '_' + std::to_string(G.GENSYM_HASH_IDX_1++);
  }


  // If given an arg, return the nth previously generated gensym symbol
  string decremented_hashed_gensym_arg(size_type n, const data_vector& args){
    static constexpr const char * const format = 
      "\n     (gensym <optional-instance-#-to-reference>)"
      "\n     => (gensym n) refers to the symbol generated by the nth last (gensym) call!";
    if(!G.GENSYM_HASH_IDX_2 && G.GENSYM_HASH_IDX_1 < n)
      HEIST_THROW_ERR("'gensym less than " << n << " gensym instances have been generated!"
        << format << HEIST_FCN_ERR("gensym",args));
    if(G.GENSYM_HASH_IDX_1 < n) {
      n -= G.GENSYM_HASH_IDX_1;
      return symconst::gensym_prefix + std::to_string(G.GENSYM_HASH_IDX_2 - 1) + 
                                 '_' + std::to_string(GLOBALS::MAX_SIZE_TYPE - n);
    } else {
      return symconst::gensym_prefix + std::to_string(G.GENSYM_HASH_IDX_2) + 
                                 '_' + std::to_string(G.GENSYM_HASH_IDX_1 - n);
    }
  }

} // End of namespace heist::stdlib_gensyms

#endif