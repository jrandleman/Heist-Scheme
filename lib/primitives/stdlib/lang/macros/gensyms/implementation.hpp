// Author: Jordan Randleman -- jrandleman@scu.edu -- implementation.hpp
// => Defines helper functions for gensyms.hpp

#ifndef HEIST_SCHEME_CORE_STDLIB_GENSYMS_IMPLEMENTATION_HPP_
#define HEIST_SCHEME_CORE_STDLIB_GENSYMS_IMPLEMENTATION_HPP_

namespace heist::stdlib_gensyms {

  /******************************************************************************
  * GENSYM
  ******************************************************************************/

  // Returns a freshly generated gensym symbol
  string new_hashed_gensym_arg()noexcept{
    if(G.GENSYM_HASH_IDX_1 != GLOBALS::MAX_SIZE_TYPE)
      return symconst::gensym_prefix + std::to_string(G.GENSYM_HASH_IDX_2) + 
                                 '_' + std::to_string(G.GENSYM_HASH_IDX_1++);
    return symconst::gensym_prefix + std::to_string(++G.GENSYM_HASH_IDX_2) + 
                               '_' + std::to_string(G.GENSYM_HASH_IDX_1++);
  }


  // If given an arg, return the nth previously generated gensym symbol
  string decremented_hashed_gensym_arg(size_type n, const data_vector& args){
    static constexpr const char * const format = 
      "\n     (gensym <optional-instance-#-to-reference>)"
      "\n     => (gensym n) refers to the symbol generated by the nth last (gensym) call!";
    if(!G.GENSYM_HASH_IDX_2 && G.GENSYM_HASH_IDX_1 < n)
      HEIST_THROW_ERR("'gensym less than " << n << " gensym instances have been generated!"
        << format << HEIST_FCN_ERR("gensym",args));
    if(G.GENSYM_HASH_IDX_1 < n) {
      n -= G.GENSYM_HASH_IDX_1;
      return symconst::gensym_prefix + std::to_string(G.GENSYM_HASH_IDX_2 - 1) + 
                                 '_' + std::to_string(GLOBALS::MAX_SIZE_TYPE - n);
    } else {
      return symconst::gensym_prefix + std::to_string(G.GENSYM_HASH_IDX_2) + 
                                 '_' + std::to_string(G.GENSYM_HASH_IDX_1 - n);
    }
  }

  /******************************************************************************
  * SYMBOL-APPEND
  ******************************************************************************/

  data convert_symbol_append_result_to_a_datum(const string& s)noexcept{
    if(s == symconst::true_t) return GLOBALS::TRUE_DATA_BOOLEAN;
    if(s == symconst::false_t) return GLOBALS::FALSE_DATA_BOOLEAN;
    num_type num;
    if(convert_string_to_scm_number(s,num)) return num; // from lib/core/reader/parser.hpp
    return s;
  }

} // End of namespace heist::stdlib_gensyms

#endif