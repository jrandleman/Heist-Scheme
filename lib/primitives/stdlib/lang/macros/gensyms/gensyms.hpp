// Author: Jordan Randleman -- jrandleman@scu.edu -- gensyms.hpp
// => Defines the primitive gensym functions written in C++ for the Heist Scheme Interpreter

#ifndef HEIST_SCHEME_CORE_STDLIB_GENSYMS_HPP_
#define HEIST_SCHEME_CORE_STDLIB_GENSYMS_HPP_

#include "implementation.hpp"

namespace heist {

  /******************************************************************************
  * SYMBOL-APPEND
  ******************************************************************************/

  data primitive_SYMBOL_APPEND(data_vector&& args) {
    if(args.empty())
      HEIST_THROW_ERR("'symbol-append received incorrect # of args!"
        "\n     (symbol-append <symbol-1> ... <symbol-N>)" 
        << HEIST_FCN_ERR("symbol-append", args));
    for(size_type i = 0, n = args.size(); i < n; ++i)
      if(!args[i].is_type(types::sym))
        HEIST_THROW_ERR("'symbol-append arg #" << i+1 << ' ' << HEIST_PROFILE(args[i])
          <<" isn't a symbol!\n     (symbol-append <symbol-1> ... <symbol-N>)" 
          << HEIST_FCN_ERR("symbol-append", args));
    string appended_symbol;
    for(size_type i = 0, n = args.size(); i < n; ++i)
      appended_symbol += args[i].sym;
    return appended_symbol;
  }

  /******************************************************************************
  * GENSYMS
  ******************************************************************************/

  data primitive_GENSYM(data_vector&& args) {
    static constexpr const char * const format = 
      "\n     (gensym <optional-instance-#-to-reference>)"
      "\n     => (gensym n) refers to the symbol generated by the nth last (gensym) call!";
    if(args.size() > 1)
      HEIST_THROW_ERR("'gensym received incorrect # of args!" << format << HEIST_FCN_ERR("gensym",args));
    if(args.size() == 1) {
      if(!args[0].is_type(types::num) || !args[0].num.is_integer() || args[0].num.is_neg())
        HEIST_THROW_ERR("'gensym arg " << HEIST_PROFILE(args[0]) << " isn't a non-negative integer!"
          << format << HEIST_FCN_ERR("gensym",args));
      return stdlib_gensyms::decremented_hashed_gensym_arg((size_type)args[0].num.extract_inexact(),args);
    }
    return stdlib_gensyms::new_hashed_gensym_arg();
  }


  data primitive_SOWN_GENSYM(data_vector&& args) {
    static constexpr const char * const format = 
      "\n     (sown-gensym <seed>)"
      "\n     => <seed> = number | symbol | boolean";
    if(args.size() != 1)
      HEIST_THROW_ERR("'sown-gensym received incorrect # of args!" 
        << format << HEIST_FCN_ERR("sown-gensym",args));
    if(!args[0].is_type(types::num) && !args[0].is_type(types::sym) && !args[0].is_type(types::bol))
      HEIST_THROW_ERR("'sown-gensym arg "<<HEIST_PROFILE(args[0])<<" isn't a valid 'sown-gensym key!" 
        << format << HEIST_FCN_ERR("sown-gensym",args));
    return symconst::gensym_prefix + string("sown-") + args[0].write();
  }

} // End of namespace heist

#endif