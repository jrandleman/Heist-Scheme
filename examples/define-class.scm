;; Author: Jordan Randleman -- define-class.scm
;; => Implements a basic object system via Closures & Macros

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Our objects will be represented as closures generated by macros.
;; Our objects will operate via message-passing, and support single-inheritance.
;;   => "object.method(arg1, arg2)" is written as "(object (quote method) arg1 arg2)"

;; Setters & getters will be generated for fields.
;; The "*this*" function object will exist to refer to the object itself in methods.
;; The "*super*" function object will exist to refer to the inherited super object in methods
;; The "*type*" method will return the name of the object's class
;; Fields may be set during construction by passing values to the constructor in 
;;   the same order as the class' field definitions.


#| 

;; Our class definitions will look as follows:

(define-class Rectangle ()
  (width 0) ; "width" field with a default value of 0
  (height 0) ; "height" field with a default value of 0
  ((area) (* width height)) ; "area" method
  ((perimeter) (* 2 (+ width height)))) ; "perimeter" method


(define-class Square (Rectangle) ; "Square" inherits from "Rectangle"
  ((get-length) (*super* 'get-width)) ; Add a psuedo-getter for "length"
  ((set-length! v) ; Add a psuedo-setter for "length"
    (*super* 'set-width! v) 
    (*super* 'set-height! v)))


(define sqr (Square))
(sqr 'set-length! 10)
(display (sqr 'area)) ; use the "area" method of the inherited "Rectangle" super object

 |#


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Super Object Value Parsing

(define (heist:lib:define-class:parse-super-object class-name super-object)
  (if (null? super-object)
      `(lambda (heist:lib:define-class:msg . _) 
          (error (quote ,class-name) "Invalid message" heist:lib:define-class:msg))
      super-object))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Field Parsing & Generation

(define (heist:lib:define-class:parse-field-values fields)
  (filter \(symbol? (car %1)) fields))


(define (heist:lib:define-class:generate-field-getters-&-setters field-values getters-&-setters)
  (if (null? field-values)
      getters-&-setters
      (begin
        (define field-name (caar field-values))
        (heist:lib:define-class:generate-field-getters-&-setters 
          (cdr field-values) 
          (cons `((eq? heist:lib:define-class:msg (quote ,(symbol-append 'get- field-name))) ,field-name)
                 (cons `((eq? heist:lib:define-class:msg (quote ,(symbol-append 'set- field-name '!))) 
                          (set! ,field-name (car heist:lib:define-class:params)))
                        getters-&-setters))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Method Parsing & Generation

(define (heist:lib:define-class:parse-method-defines fields)
  (filter \(pair? (car %1)) fields))


(define (heist:lib:define-class:generate-method-defines methods)
  (map \(cons 'define %1) methods))


(define (heist:lib:define-class:generate-method-dispatch methods)
  (map 
    (lambda (method) 
      (define method-name (caar method))
      `((eq? heist:lib:define-class:msg (quote ,method-name)) 
        (apply ,method-name heist:lib:define-class:params)))
    methods))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Main Macro Parsing Logic

(define (heist:lib:define-class:parse expr)
  (define class-name (cadr expr))
  (define *super* (heist:lib:define-class:parse-super-object class-name (caddr expr)))
  ; Parse Fields
  (define fields (cdddr expr))
  (define field-values (heist:lib:define-class:parse-field-values fields))
  (define field-getters-&-setters (heist:lib:define-class:generate-field-getters-&-setters field-values '()))
  ; Parse Methods
  (define methods (heist:lib:define-class:parse-method-defines fields))
  (define method-defines (heist:lib:define-class:generate-method-defines methods))
  (define method-dispatchers (heist:lib:define-class:generate-method-dispatch methods))
  ; Return the function object constructor code
  `(define (,class-name ,@field-values)
    (define *super* ,*super*)
    ,@method-defines
    (define (*this* heist:lib:define-class:msg . heist:lib:define-class:params)
      (cond
        ,@field-getters-&-setters
        ,@method-dispatchers
        ((eq? heist:lib:define-class:msg '*super*)
          (apply *super* heist:lib:define-class:params))
        ((eq? heist:lib:define-class:msg '*type*)
          (quote ,class-name))
        (else 
          (apply *super* (cons heist:lib:define-class:msg heist:lib:define-class:params)))))
    *this*))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Macro Parser Dispatch

(core-syntax define-class heist:lib:define-class:parse)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Testing our work

(define-class Rectangle ()
  (width 0)  ; "width" field with a default value of 0
  (height 0) ; "height" field with a default value of 0
  ((area) (* width height))             ; "area" method
  ((perimeter) (* 2 (+ width height)))) ; "perimeter" method


(define-class Square (Rectangle) ; Inherit from "Rectangle"
  ((get-length) (*super* 'get-width)) ; Add a psuedo-getter for "length"
  ((set-length! v)                    ; Add a psuedo-setter for "length"
    (*super* 'set-width! v) 
    (*super* 'set-height! v)))


(define sqr (Square))
(sqr 'set-length! 10)
(displayf ">> Area of \"sqr\" with length of %n is %n\n" (sqr 'get-length) (sqr 'area))
(displayf ">> Perimeter of \"sqr\" with length of %n is %n\n" (sqr 'get-length) (sqr 'perimeter))


(display "\n\n>> Expanding the \"Rectangle\" class definition macro:\n")
(pprint 
  (expand* 
    '(define-class Rectangle ()
      (width 0)
      (height 0)
      ((area) (* width height))
      ((perimeter) (* 2 (+ width height))))))


(display "\n\n\n>> Expanding the \"Square\" class definition macro:\n")
(pprint 
  (expand* 
    '(define-class Square (Rectangle)
      ((get-length) (*super* 'get-width))
      ((set-length! v)
        (*super* 'set-width! v) 
        (*super* 'set-height! v)))))


(newline)
